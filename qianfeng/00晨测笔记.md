# 晨测

### 晨测0728

#### final和finally区别

* `final`：final修饰的变量变成常量，修饰的方法无法被重写，修饰的类不能被继承。
* `finally`：在捕获异常时使用，表示最终执行的代码块。

#### 抽象类和接口的区别

* 抽象类中包含普通方法和抽象方法
* 接口中只能包含抽象方法
* 抽象类只能单继承
* 接口可以被多重实现，即一个类可以实现多个接口
* 抽象类之间只能单继承
* 接口之间可以多继承，public interface i1 extend i2, i3
* 抽象类中包含构造方法，接口中无构造方法
* 抽象类中包含普通的全局变量，而接口只能包含静态常量

### 晨测0729

#### ==和equals的区别是什么？

* ==应用于基本数据类型，比较的是值；应用于引用数据类型，比较的是地址。

* equals是Object提供的方法，应用在引用数据类型，默认比较的是地址，但是equals 重写时，根据重写的方式进行比较，往往比较的是应用数据类型的内容。

#### 两个对象的hashCode()相同，则equals()也一定为true，对吗？

Java中规定，重写equals则必须重写hashCode()，equals一旦相等，就意味着本质上的hashCode也得相等。

 **不对**

hashCode相同，则表示地址相同，地址相同则表示同一个对象，同一个对象则表示equals一定相同。

equals为true时，hashCode在重写的情况下，是相等的。但是如果hashCode没有重写，那么hashCode有可能不相等。

### 晨测0730

#### 多线程实现的方式有哪些？

1. 继承Thread类

2. 实现Runnable接口，重写run方法，无返回值，没有抛出的异常

3. 实现Callable接口，重写call方法，有返回值，可以抛出异常

#### 反射对象创建的方式有哪些？

1. Class.forName

2. 对象.gerClass

3. 类名.class

#### 重载和重写的区别是什么？

* **重载**是发生在同一个类中的，方法名相同，但是参数列表不同

* **重写**是发生在继承关系的两个类中，方法的定义完全相同，方法体不同

### 晨测0731

#### PerparedStatment和Statement的区别

* Statement：执行完整SQL，无法防止SQL注入
* PreparedStatement属于Statement的子接口，对SQL语句进行预编译，能够防止SQL注入，同时也会节省SQL运行的时间

#### Vector，ArrayList，LinkedList的区别

都是List接口的实现类

* Vector：线程安全的，Vector的执行方法和ArrayList基本相同，Vector在数据达到其初始容量的临界值时，会进行成倍的扩展
* ArrayList：非线程安全，扩展时是0.5倍的扩展
* LnkedList：采取的链表结构，非线程安全，增删快，查询慢，ArrayList和Vector都是增删慢，查询快

#### 列举MySQL中提供的索引类型

1. 普通索引

2. 主键索引

3. 唯一索引

4. 全文索引

### 晨测0803

#### 事务（ACID）的四大特性

1. 原子性：事务的操作就是一组SQL组成的一个单元，共同执行成功或者不成功
2. 一致性：事务操作的过程中保证数据的一致
3. 隔离性：事务操作并发时要各个事务之间相互隔离，互不影响
4. 持久性：事务成功的操作对数据的影响是永久的

#### delete、drop、truncate的区别

* delete：删除表中的数据，对主键索引序列无影响
* drop：删除整张表数据
* truncate：清空表数据，对主键索引序列有影响

#### MySQL中varchar和char的区别

* varchar不固定长度，设定了varchar的长度，存储多少数据，长度即为多少
* char固定长度，存储的数据低于设定长度，填补齐所缺失的长度

#### Collection和Collections的区别

* Collection集合接口，提供的是集合操作的规范
* Collections工具类，提供的是集合操作的各种工具方法

#### 多线程中的Runnable和Callable的区别

* Runnable重写run方法，无返回值，无异常操作
* Callable重写call方法，有返回值，有异常操作，所以往往用于线程池内多线程共同计算数据

#### sleep()和wait()的区别

* sleep：Thread中提供的静态方法，线程休眠，线程进入阻塞状态，休眠时间结束，才会进入就绪状态，随时等待CPU分配时间片
* wait：Object中提供的方法，释放同步锁，等待被其他线程唤醒。

### 晨测0804

#### 线程的sleep()方法和yield()方法有什么区别？

* sleep：线程休眠，线程进入阻塞状态，等待休眠时间结束以后，重新就绪状态等待CPU分配时间片

* yield：线程的暂停，直接将线程交还到就绪状态，理论上将时间片让给优先级相同或者比其高的线程，也可能本线程会重新执行

#### synchronized和Lock 有什么区别？

* synchronize可以在方法上加锁，也可以在代码段中加锁，执行完毕后会自动释放锁
* Lock需要手动加锁，同样也需要手动释放锁

#### HashTable和ConcurrentHashMap的区别

* HashTable线程安全，通过在方法上加synchronize实现加锁
* ConcurrentHashMap在jdk1.7以前采用了分段锁，（segment），一般数据安段划分，操作某条数据，该段下就会加锁。jdk1.8后采用了CAS（比较交换）算法和synchronize结合进行加锁。CAS算法提供了三个参数（k, v, n），如果一个线程操作了该条数据，先查询k所对应是不是最新的k，如果不还是，表示有线程在操作该条数据，本线程需要等待，如果是，采用synchronize进行同步锁，采用synchronize进行同步锁，等到操作完成后，会将n的值付给k

#### TCP和UDP的区别

* TCP：面向连接，可靠的，采用三次握手，四次挥手的机制，保证通信完整，采用流的形式进行数据传输
* UDP：面向无连接，不可靠的，采用数据报的形式进行数据传输

#### java有多少种内部类

* 成员内部类
* 匿名内部类
* 静态内部类
* 局部内部类

#### 成员变量、局部变量是否可以不初始化？

局部变量必须初始化，一般访问的是栈中的变量必须初始化 

成员变量可以不初始化，一般放置在堆中，堆中对该变量设有默认值



